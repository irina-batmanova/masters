\documentclass[16pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{ amssymb }
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{ dsfont }

\usepackage{ upgreek }


\title{Проверка эквивалентности CDP}

\theoremstyle{definition}
\newtheorem{definition}{Определение}[section]





\begin{document}

\maketitle

\section{Введение}

\begin{definition}[CDP] 
Комбинаторный дивизориальный многогранник (combinatorial divisorial polytope) относительно решетки M состоит из многогранника $\square \subset M \otimes \mathds{R}$ и кортежа $(\psi_1, \dots, \psi_n)$ кусочно-линейных вогнутых функций $\psi_i: \square \rightarrow \mathds{R}$ таких что
\begin{itemize}
	\item[1] Для всех $i$ граф $\psi_i$ - полиэдральный комплекс с целочисленными вершинами
	\item[2] $\forall u \in \square^{\circ} \sum_{i=1}^n\psi_i(u) > 0$
\end{itemize}
$\square$ называется \emph{базой} CDP
\end{definition}

\\

\subsection{Преобразования CDP}
Пусть дан исходный CDP c набором функций $(\psi_1, \dots, \psi_n)$ и базой $\square$

\begin{definition}[Трансформация базы (transformation of the base)]
Пусть $\phi$ - линейное обратимое преобразование решетки $M$, тогда CDP с базой $\phi(\square)$ и набором функций 
$\psi_i \circ \phi^{-1}$ получен из исходного с помощью  трансформации базы.
\end{definition}

\begin{definition}[Скашивание (shearing action)]
Пусть $v \in M^*, \beta_1, \dots, \beta_n \in \mathds{Z}$, тогда CDP с базой $\square$ и набором функций $u \mapsto
 \psi_i(u) + \beta_i<u, v>, \forall u \in \square$, получен из исходного с помощью скашивания.
\end{definition}

\begin{definition}[Перенос (translation)]
Пусть $\alpha_1, \dots, \alpha_n \in \mathds{Z}
$, $\sum_{i=1}^n \alpha_i = 0$, тогда CDP с базой $\square$ и набором функций $\psi_i + \alpha_i$ получен из исходного с помощью переноса.
\end{definition}

\subsection{Эквивалентность}
\begin{definition}[Эквивалентные CDP]
CDP, полученный из исходного с помощью преобразований скашивания, переноса и трансформации базы, примененных в любой последовательности и в любых количествах, эквивалентен исходному.
\end{definition}

\section{Алгоритм проверки эквивалентности}
Считаем, что трансформация базы всегда происходит только 1 раз, и это первая операция в цепочке преобразований (ниже будет доказано, почему такое предположение корректно)
\\
Введем операцию обобщенного скашивания

\begin{definition}[Обобщенное скашивание]
пусть $\sum_{i=1}^n v_i = 0$, тогда CDP с базой $\square$ и набором функций $u \mapsto \psi_i(u) + <u, v_i>$ получен из исходного с помощью обобщенного скашивания.
\end{definition}
Пусть $CDP_1$ имеет базу $\square$ и набор функций $(\psi_1, \dots, \psi_n)$, а $CDP_2$ - базу $\square^{'}$ и набор функций $(\psi^{'}_1, \dots, \psi^{'}_n)$, проверим их на эквивалентность:
\begin{itemize}
\item[1] Выберем нумерацию вершин в $\square'$
\item[2] Найдем такую матрицу $A$, которая переводит $\square$ в $\square'$ (с учетом нумерации вершин), найдем матрицу обратного преобразования - $A^{-1}$, применим это преобразование к $\psi_1, ..., \psi_n$, получим $\upchi_1 := \psi_1\phi^{-1}, ..., \upchi_n := \psi_n\phi^{-1}$. Если такой матрицы нет - возвращаемся на шаг 1 и выбираем другую нумерацию. 
% TODO: расписать про эквивалентность (добавить формальности)
% TODO: добавить картинку про эквивалентность
\item[3] Разобьем функции в обоих наборах на классы эквивалентности: совпадают области линейности - один класс. Для каждой функции первого набора должна найтись функция второго набора с такими же областями линейности, и наоборот (но может быть несколько функций с одинаковыми областями линейности в одном наборе, поэтому нужны классы эквивалентности). Если не получилось найти такое соответствие между двумя наборами - CDP не эквивалентны, алгоритм завершается.
% TODO: расписать формальнее
\item[3] Каждая функция представляется в виде набора коэффициентов $a_0, a_1, \dots, a_m$, где $a_0$ - свободный коэффициент (константа), а $a_1, \dots, a_m$ - коэффициенты перед переменными $x_1, \dots, x_m$. Пусть у функции из первого набора коэффициенты $a_{i0}, a_{i1}, \dots, a_{im}$, из второго - $b_{i0}, b_{i1}, \dots, b_{im}$, надо чтобы $\sum_{i=1}^{n}(b_{i0} - a_{i0}) = 0$, тогда существует перенос. 
Работаем с переносами, после переносов функции обозначаем $\upchi^{'}_i$
% TODO: нормально описать поиск векторов
\item[5] Для каждой пары функций из предыдущего пункта пытаемся найти вектор $v_i$, такой что $\upchi^{'}_i(u) + <u, v_i> = \psi^{'}_i(u)$ (для всех линейных кусков должен получиться одинаковый вектор), если получилось и $\sum_{i=1}^n v_i = 0$ - CDP эквивалентны, если нет - пробуем по-другому составить пары согласно классам эквивалентности и повторяем пункт 5, если попробовали все пары и не получилось - переходим в пункт 1
\item[5] Если оказались здесь - CDP не эквивалентны

\end{itemize}
% TODO: пример работы алгоритма?

\section{Доказанные факты}
\subsection{Трансформацию базы можно всегда считать первой в цепочке преобразований}
Пусть $CDP_1\ (\square, \psi_1, ..., \psi_n)$ переводится в $CDP_2\ (\square^{'}, \psi_1^{'}, ..., \psi_n^{'})$ с помощью цепочки преобразований $BC$, где $B$ - операция скашивания, $C$ - трансформация базы. Покажем, что тогда существует другая цепочка преобразований - $C^{'}B^{'}$, где  $C^{'}$ - трансформация базы, $B^{'}$ - операция скашивания, - которая также переводит $CDP_1$ в $CDP_2$.
\\
$\psi_i(u) \xrightarrow[]{C^{'}B^{'}} \psi_i^{'}(u_{new}) = \psi_i(\phi^{-1}(u_{new})) + \beta_i<u_new, v>$
\\
$\psi_i(u) \xrightarrow[]{B} \psi_i(u) + \beta_i<u, v_1>$, положим $v_1 = \phi(v)$, тогда $\psi_i(u) \xrightarrow[]{B} \psi_i(u) + \beta_i<u, \phi(v)>$, теперь применим трансформацию $C$: 
$\psi_i(u) \xrightarrow[]{BC} \psi_i(\phi^{-1}(u_{new})) + \beta_i<\phi^{-1}(u_{new}), \phi(v)> = \psi_i(\phi^{-1}(u_{new})) + \beta_i<u_{new}, v> = \psi_i^{'}(u_{new})$, то есть цепочки преобразований $BC$ и $C^{'}B^{'}$ дают одинаковый результат

Аналогично для операции переноса (translation)

\subsection{Можно считать, что трансформация базы происходит только 1 раз в цепочке преобразований}
Все трансформации базы можно перенести в начало цепочки по предыдущему пункту, а композиция линейных обратимых преобразований также является линейным обратимым преобразованием, поэтому можно заменить композицию трансформаций на единственную трансформацию базы.

\subsection{Перенос и скашивание можно менять местами}
$\psi_i(u) + \beta_i<u, v> + \alpha_i = \psi_i(u) + \alpha_i + \beta_i<u, v>$

\subsection{Два переноса можно объединить в один}
$\psi_i + \alpha_i + \alpha^{'}_i$, $\sum_{i=1}^n\alpha_i = 0$, $\sum_{i=1}^n\alpha^{'}_i = 0$ - значит и $\sum_{i=1}^n(\alpha_i + \alpha^{'}_i) = 0$, тогда $\psi_i + \alpha^{''}_i$, $\alpha^{''}_i = \alpha_i + \alpha^{'}_i$ - корректный перенос.

\subsection{Если CDP эквивалентны, то $\sum_{i=1}^n v_i = 0$ на 5 шаге алгоритма}
Когда алгоритм достигает 5 шага - к набору функций $\psi_i$ уже применены трансформация базы и перенос, доказано, что можно считать, что эти операции происходят в цепочке преобразований только по одному разу - значит, чтобы перевести $\upchi^{'}_i$ в $\psi^{'}_i$, можно применять только скашивания. 
Пусть $\upchi^{'}_i(u) \mapsto \upchi^{'}_i(u) + \beta_i<u, v> + \beta_i^{'}<u, v^{'}>$, 
$\beta_i<u, v> + \beta_i^{'}<u, v^{'}> = v_i$, 
$\sum_{i=1}^{n} \beta_i = 0$, 
$\sum_{i=1}^{n} \beta^{'}_i = 0$, 
тогда $\sum_{i=1}^{n} \beta_i<u, v>= 0$ и $\sum_{i=1}^{n} \beta^{'}_i<u, v>= 0$, 
а значит $\sum_{i=1}^{n} v_i = 0$ (аналогично для любого числа обычных скашиваний в цепочке)
% TODO
\subsection{Любое обобщенное скашивание можно представить в виде суммы обычных}
Пусть $v_1, \dots, v_n$ - обобщенное скашивание. Покажем, что $v_i$ можно представить в виде $\beta_{i1}v^{'}_1 + \dots + \beta_{ik}v^{'}_k$, $\forall j \sum_{i=1}^n\beta_{ij} = 0 $
\\
\def\vf{
\begin{bmatrix}
    a_{11} \\
    a_{21} \\
    \vdots \\
    a_{m1}
\end{bmatrix}}

\def\vs{
\begin{bmatrix}
    a_{12} \\
    a_{22} \\
    \vdots \\
    a_{m2}
\end{bmatrix}}

\def\vn{
\begin{bmatrix}
    a_{1n} \\
    a_{2n} \\
    \vdots \\
    a_{mn}
\end{bmatrix}}

\def\basef{
\begin{bmatrix}
    1 \\
    0 \\
    0 \\
    \vdots \\
    0
\end{bmatrix}}

\def\bases{
\begin{bmatrix}
    0 \\
    1 \\
    0 \\
    \vdots \\
    0
\end{bmatrix}}

\def\basem{
\begin{bmatrix}
    0 \\
    0 \\
    \vdots \\
    0 \\
    1
\end{bmatrix}}

\begin{equation}
v_1 = \vf, \dots, v_n = \vn
\end{equation}

\begin{align*} 
%\begin{equation}

\vf = a_{11}\basef + a_{21}\bases + \dots + a_{m1}\basem
%\end{equation}


%\begin{equation}
\vs = a_{12}\basef + a_{22}\bases + \dots + a_{m2}\basem

\vdots

\vn = a_{1n}\basef + a_{2n}\bases + \dots + a_{mn}\basem
%\end{equation}
\end{align*}

$\forall i \sum_{j=1}^na_{ij} = 0$ (суммы коэффициентов в столбцах), поскольку $\sum_{i=1}^{n} v_i = 0$. 
\\
Значит, $a_{1j}\basef$, $a_{2j}\bases$, \dots, $a_{mj}\basem$ -  корректные операции скашивания (в качестве вектора $v$ для каждого преобразования берем базисный вектор, а в качестве коэффициентов $\beta_i$ - координаты исходных векторов).

Таким образом, если в пункте 4 нашли обобщенное скашивание, которое переводит $CDP_1$ в $CDP_2$ - найдется и последовательность обычных, которые делают то же самое.




\end{document}	